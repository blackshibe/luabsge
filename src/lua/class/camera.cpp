#include "camera.h"

int camera_index(lua_State *L) {
	return 0;
}

int camera_newindex(lua_State *L) {
	const char *index = lua_tostring(L, 2);

	if (strcmp(index, "position") == 0) {
		BSGECameraMetadata *camera = (BSGECameraMetadata *)lua_touserdata(L, 1);
		glm::mat4 *position = (glm::mat4 *)lua_touserdata(L, 3);
		camera->matrix = *position;

		return 0;
	}

	return 0;
}

void camera_set_shader_projection_matrix(sol::state &lua, BSGEWindow *context_window) {
	sol::table world = lua["World"];
	sol::table rendering = world["rendering"];
	sol::optional<BSGECameraMetadata*> camera_opt = rendering["camera"];

	BSGECameraMetadata* camera = camera_opt.value();
	glm::mat4 camera_projection = camera_get_projection_matrix(*camera);

	glUniformMatrix4fv(glGetUniformLocation(context_window->default_shader, "camera_transform"), 1, GL_FALSE, glm::value_ptr(camera->matrix));
	glUniformMatrix4fv(glGetUniformLocation(context_window->default_shader, "projection"), 1, GL_FALSE, glm::value_ptr(camera_projection));
}

static glm::vec2 current_buffer_dimensions;
glm::vec2 get_current_buffer_dimensions() {
	return glm::vec2(current_buffer_dimensions.x, current_buffer_dimensions.y);
}

void set_current_buffer_dimensions(glm::vec2 dimensions) {
	current_buffer_dimensions = dimensions;
}

glm::mat4 camera_get_projection_matrix(BSGECameraMetadata camera) {
	glm::vec2 dimensions = get_current_buffer_dimensions();
	glm::mat4 camera_projection = glm::perspective(glm::radians(camera.fov), (float)dimensions.x / (float)dimensions.y, camera.near_clip, camera.far_clip);

	return camera_projection;
}

glm::mat4 camera_get_projection_matrix_for_resolution(BSGECameraMetadata camera, float x, float y) {
	glm::mat4 camera_projection = glm::perspective(glm::radians(camera.fov), x / y, camera.near_clip, camera.far_clip);

	return camera_projection;
}

const luaL_Reg bsge_lua_camera_metatable_access[] = {
	{"__index", camera_index},
	{"__newindex", camera_newindex},

	{NULL, NULL},
};

// Test for autogenerated docs
void lua_bsge_init_camera(sol::state &lua) {
	lua.new_usertype<BSGECameraMetadata>(
		// @class Camera Camera type for LuaBSGE
		"Camera",
		sol::constructors<BSGECameraMetadata()>(),
		// @field position table Camera position
		// @field fov number Field of view in degrees (default: 70.0)
		"fov", &BSGECameraMetadata::fov,
		// @field near_clip number Near clipping plane distance (default: 0.1)
		"near_clip", &BSGECameraMetadata::near_clip,
		// @field far_clip number Far clipping plane distance (default: 100.0)
		"far_clip", &BSGECameraMetadata::far_clip,
		// @field matrix table 4x4 transformation matrix (glm::mat4)
		"matrix", &BSGECameraMetadata::matrix,
		// @field get_projection_matrix returns perspective matrix 
		"get_projection_matrix", camera_get_projection_matrix,
		"get_projection_matrix_for_resolution", camera_get_projection_matrix_for_resolution
	);
}
