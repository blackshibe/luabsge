Shader "Custom/NewBlitScriptableRenderPipelineShader"
{
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100
        ZWrite Off
        Cull Off
        
        HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl"

        float4x4 _CameraInvProj;     // inverse projection matrix
        float4x4 _CameraToWorld;     // camera-to-world matrix
        float3 _CameraPosition;     // camera-to-world matrix

        struct ShaderVaryings
        {
            float4 positionHCS : SV_POSITION;
            float2 uv         : TEXCOORD0;
        };

        struct TracerRayHitInfo { 
            float Distance;
            float3 Normal;
            bool Hit;
        };

        float3 GetPixelWorldDirection(float2 uv) {
            float2 ndc = uv * 2.0 - 1.0; // convert uv to clip space (-1, 1)
            float4 clipPos = float4(-ndc.x, -ndc.y, 0, 1); // clip position is camera clip position
            float4 viewPos = mul(_CameraInvProj, clipPos); // transform it from clip space to camera space or something

            float3 viewDir = normalize(viewPos.xyz / viewPos.w); // viewDir is the direction from the camera to the pixel in view space
            float3 worldRayDirection = normalize(mul((float3x3)_CameraToWorld, viewDir)); // unity_CameraInvView is the camera-to-world matrix

            return worldRayDirection;
        }

        TracerRayHitInfo RaySphereIntersect(float3 SpherePos, float SphereRadius, float3 RayOrigin, float3 RayDir) {
            // quadratic formula expression of x^2 + y^2 + z^2 = r^2 transformed into ||P+Dx||^2 = R^2
            TracerRayHitInfo rayInfo = (TracerRayHitInfo)0;

            float a = dot(RayDir, RayDir);
            float b = 2 * dot(RayOrigin, RayDir);
            float c = dot(RayOrigin, RayOrigin) - SphereRadius * SphereRadius;

            float delta = b * b - 4 * a * c;

            if (delta >= 0) {
                float intersect1 = (-b + sqrt(delta)) / 2 * a;
                float intersect2 = (-b - sqrt(delta)) / 2 * a;
                float minIntersect = min(intersect1, intersect2);

                if (minIntersect < 0) {
                    rayInfo.Hit = true;
                    rayInfo.Distance = -minIntersect;
                    rayInfo.Normal = normalize((RayDir * minIntersect) - SpherePos);
                }
            }

            return rayInfo;
        }

        float4 Frag(ShaderVaryings IN) : SV_Target
        {
            float3 worldDir = GetPixelWorldDirection(IN.uv);

            TracerRayHitInfo test = RaySphereIntersect(float3(0.0, 0.0, 0.0), 2.0, _CameraPosition, worldDir); 
            if (test.Hit) {
                return float4(test.Normal.x, test.Normal.y, test.Normal.z, 1.0);
            }

            return float4(worldDir.r, worldDir.y, worldDir.z, 1.0);
        }
        ENDHLSL

        Pass
        {
            Name "NewBlitScriptableRenderPipelineShader"
            HLSLPROGRAM
            #pragma vertex Vert
            #pragma fragment Frag
            ENDHLSL
        }
    }
}
