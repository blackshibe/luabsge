#include "camera.h"

int camera_index(lua_State *L) {
	return 0;
}

int camera_newindex(lua_State *L) {
	const char *index = lua_tostring(L, 2);

	if (strcmp(index, "position") == 0) {
		BSGECameraMetadata *camera = (BSGECameraMetadata *)lua_touserdata(L, 1);
		glm::mat4 *position = (glm::mat4 *)lua_touserdata(L, 3);
		camera->matrix = *position;

		return 0;
	}

	return 0;
}

glm::mat4 camera_get_projection_matrix(BSGECameraMetadata camera) {
	glm::vec2 dimensions = get_window_dimensions();
	glm::mat4 camera_projection = glm::perspective(glm::radians(camera.fov), (float)dimensions.x / (float)dimensions.y, camera.near_clip, camera.far_clip);

	return camera_projection;
}

const luaL_Reg bsge_lua_camera_metatable_access[] = {
	{"__index", camera_index},
	{"__newindex", camera_newindex},

	{NULL, NULL},
};

// Test for autogenerated docs
void lua_bsge_init_camera(sol::state &lua) {
	lua.new_usertype<BSGECameraMetadata>(
		// @class Camera Camera type for LuaBSGE
		"Camera",
		sol::constructors<BSGECameraMetadata()>(),
		// @field position table Camera position
		// @field fov number Field of view in degrees (default: 70.0)
		"fov", &BSGECameraMetadata::fov,
		// @field near_clip number Near clipping plane distance (default: 0.1)
		"near_clip", &BSGECameraMetadata::near_clip,
		// @field far_clip number Far clipping plane distance (default: 100.0)
		"far_clip", &BSGECameraMetadata::far_clip,
		// @field matrix table 4x4 transformation matrix (glm::mat4)
		"matrix", &BSGECameraMetadata::matrix,
		// @field get_projection_matrix returns perspective matrix 
		"get_projection_matrix", camera_get_projection_matrix);
}
